[{"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/focusBoardSlice.js":"1","/home/pg07codes/Desktop/fokus/src/containers/focusBoard/index.js":"2","/home/pg07codes/Desktop/fokus/src/containers/App.js":"3","/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js":"4","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/taskBoardSlice.js":"5","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/TaskCard.js":"6","/home/pg07codes/Desktop/fokus/src/serviceWorker.js":"7","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/index.js":"8","/home/pg07codes/Desktop/fokus/src/index.js":"9","/home/pg07codes/Desktop/fokus/src/helpers/index.js":"10","/home/pg07codes/Desktop/fokus/src/store/index.js":"11"},{"size":1149,"mtime":1612351654634,"results":"12","hashOfConfig":"13"},{"size":5706,"mtime":1612363397286,"results":"14","hashOfConfig":"13"},{"size":395,"mtime":1612199237429,"results":"15","hashOfConfig":"13"},{"size":528,"mtime":1611252515979,"results":"16","hashOfConfig":"13"},{"size":6824,"mtime":1612375820558,"results":"17","hashOfConfig":"13"},{"size":9105,"mtime":1612430280275,"results":"18","hashOfConfig":"13"},{"size":5141,"mtime":1608877484447,"results":"19","hashOfConfig":"13"},{"size":4932,"mtime":1612441646517,"results":"20","hashOfConfig":"13"},{"size":651,"mtime":1608902523877,"results":"21","hashOfConfig":"13"},{"size":340,"mtime":1612282841002,"results":"22","hashOfConfig":"13"},{"size":327,"mtime":1612199332055,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"g1paqb",{"filePath":"26","messages":"27","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/focusBoardSlice.js",[],"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/index.js",["52"],"/home/pg07codes/Desktop/fokus/src/containers/App.js",[],["53","54"],"/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js",[],"/home/pg07codes/Desktop/fokus/src/containers/taskBoard/taskBoardSlice.js",["55","56","57","58"],"import { createSlice } from \"@reduxjs/toolkit\";\n\nexport const tasksSlice = createSlice({\n    name: \"tasks\",\n    initialState: {\n        taskArray: [],\n        meta: {\n            globalKey: 0,\n            completedTaskStartIndex: -1,\n        },\n    },\n    reducers: {\n        create: (tasks, { payload }) => {\n            tasks.taskArray.unshift(payload);\n            if (tasks.meta.completedTaskStartIndex != -1) ++tasks.meta.completedTaskStartIndex;\n        },\n        remove: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.filter((i) => {\n                if (i.id !== payload) return true;\n                else {\n                    if (!i.isCompleted) {\n                        if (tasks.meta.completedTaskStartIndex != -1) --tasks.meta.completedTaskStartIndex;\n                    }\n                    return false;\n                }\n            });\n        },\n        updateTask:(tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.map((i)=>i.id === payload.id?payload:i);\n        },\n        updateTaskContent: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    i.content = payload.updatedTaskContent;\n                }\n            });\n        },\n        updateOrder: (tasks, { payload }) => {\n            tasks.taskArray = payload;\n        },\n        // tick: ({ taskArray }, { payload }) => {\n        //     taskArray.forEach((i) => {\n        //         if (i.id === payload) {\n        //             i.remainingTime = i.remainingTime - 1;\n        //         }\n        //     });\n        // },\n        // reset: ({taskArray}, { payload }) => {\n        //     taskArray.forEach((i) => {\n        //         if (i.id === payload) {\n        //             i.remainingTime = i.time;\n        //             i.isRunning = false;\n        //         }\n        //     });\n        // },\n        // toggleIsRunning: ({ taskArray }, { payload }) => {\n        //     taskArray.forEach((i) => {\n        //         if (i.id === payload) {\n        //             i.isRunning = !i.isRunning;\n        //         }\n        //     });\n        // },\n        toggleIsCompleted: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    i.isCompleted = !i.isCompleted;\n                }\n            });\n        },\n        incrementGlobalKey: ({ meta }) => {\n            ++meta.globalKey;\n        },\n        rearrange: (tasks, { payload }) => {\n            let id = payload.id;\n\n            if (payload.markedAsComplete) {\n                if (tasks.meta.completedTaskStartIndex === -1) {\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                    let found = false;\n                    for (let i = 0; i < tasks.taskArray.length - 1; i++) {\n                        if(found){\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        }else if(tasks.taskArray[i].id === id){\n                            found=true;\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        }\n                    }\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                } else {\n                    let task, idx;\n                    for (let i = 0; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n                    let pos = -1;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].globalKey > task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n                    \n                    if (pos === -1) {\n                        tasks.taskArray.push(task);\n                    } else {\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.meta.completedTaskStartIndex -=1;\n                }\n            } else {\n                if (tasks.meta.completedTaskStartIndex == 0) {\n\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.taskArray.unshift(task);\n                    tasks.meta.completedTaskStartIndex = 1;\n                } else {\n\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    let start = tasks.meta.completedTaskStartIndex - 1;\n                    let pos = -1;\n                    for (let i = start; i >= 0; i--) {\n                        if (tasks.taskArray[i].globalKey < task.globalKey ) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    if (pos === -1) {\n                        tasks.taskArray.unshift(task);\n                    } else {\n                        pos++;\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.meta.completedTaskStartIndex += 1;\n\n                }\n\n                if(tasks.meta.completedTaskStartIndex==tasks.taskArray.length){\n                    tasks.meta.completedTaskStartIndex=-1;\n                }\n            }\n        },\n    },\n});\n\nexport const { create, remove, updateTask, updateTaskContent, reset, toggleIsRunning, tick, toggleIsCompleted, updateOrder, incrementGlobalKey, rearrange } = tasksSlice.actions;\n\nexport default tasksSlice.reducer;\n","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/TaskCard.js",["59","60","61"],"/home/pg07codes/Desktop/fokus/src/serviceWorker.js",[],["62","63"],"/home/pg07codes/Desktop/fokus/src/containers/taskBoard/index.js",["64","65"],"import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { create, updateOrder, incrementGlobalKey } from \"./taskBoardSlice\";\nimport TaskCard from \"./TaskCard\";\nimport { DragDropContext, Draggable, Droppable } from \"react-beautiful-dnd\";\nimport { Flipper } from \"react-flip-toolkit\";\nimport styled from \"styled-components\";\n\nconst TaskBoardContainer = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    flex: 3 1 0;\n`;\n\nconst TaskInputContainer = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin: 20px;\n    width: 576px;\n    background-color: #f8f8ff;\n    border-radius: 5px;\n    height: 75px;\n`;\n\nconst TaskInputField = styled.input`\n    height: 70%;\n    width: 90%;\n    font-size: 1em;\n    font-weight: bold;\n    border: 0;\n    outline: none;\n    background-color: #f8f8ff;\n`;\n\nconst DoneTasksDivider = styled.div`\n    width: 100px;\n    height: 10px;\n    background-color: pink;\n`;\n\nexport function TaskBoard() {\n    const tasks = useSelector((state) => state.tasks.taskArray);\n    const meta = useSelector((state) => state.tasks.meta);\n    const dispatch = useDispatch();\n\n    const [task, setTask] = useState(\"\");\n\n    function submitTask(e) {\n        if (e.key === \"Enter\" && task.trim().length >= 3) {\n            let temp = task.trim().split(\" \");\n            let time = 0;\n            if (temp.length !== 1 && !isNaN(parseInt(temp[temp.length - 1]))) {\n                time = parseInt(temp.pop());\n            } else {\n                time = 20;\n            }\n            temp = temp.join(\" \");\n\n            let newTask = {\n                id: Math.floor(Math.random() * 10000),\n                globalKey: meta.globalKey,\n                content: temp,\n                time: time * 60,\n                remainingTime: time * 60,\n                isRunning: false,\n                isCompleted: false,\n                createdAt: new Date().toISOString(),\n            };\n            dispatch(create(newTask));\n            dispatch(incrementGlobalKey());\n            setTask(\"\");\n            e.target.value = \"\";\n            e.target.focus();\n        }\n    }\n\n    function handleOnDragEnd(result) {\n        if (!result.destination) return;\n\n        let items = [...tasks.map((i) => ({ ...i }))];\n        //let items = [...tasks]\n        // let x = JSON.stringify(items);\n        // items = JSON.parse(x);\n\n        const [reorderedItem] = items.splice(result.source.index, 1);\n        items.splice(result.destination.index, 0, reorderedItem);\n\n        let i = result.source.index;\n        let direction = result.destination.index > result.source.index; // direction true means moving right & swapping\n        while (i != result.destination.index) {\n            if (direction) {\n                items[i].globalKey = tasks[i].globalKey;\n                i++;\n            } else {\n                items[i].globalKey = tasks[i].globalKey;\n                i--;\n            }\n            if (i == result.destination.index) {\n                items[i].globalKey = tasks[i].globalKey;\n            }\n        }\n\n        dispatch(updateOrder(items));\n    }\n\n    function getFlipKey() {\n        let flipKey = \"\";\n        tasks.forEach((i) => {\n            flipKey += `${i.globalKey}`;\n        });\n        return flipKey;\n    }\n\n    // input has both onChange and onKeyDown - can be optimised by using one and combining\n\n    return (\n        <TaskBoardContainer>\n            <TaskInputContainer>\n                <TaskInputField type=\"text\" onChange={(e) => setTask(e.target.value)} onKeyDown={submitTask} />\n            </TaskInputContainer>\n            <Flipper flipKey={getFlipKey()}>\n                <DragDropContext onDragEnd={handleOnDragEnd}>\n                    <Droppable droppableId=\"dropArea\">\n                        {(provided) => (\n                            <div {...provided.droppableProps} ref={provided.innerRef}>\n                                {tasks.map((i, index) =>\n                                    !i.isCompleted ? (\n                                        <Draggable isDragDisabled={i.isCompleted} key={i.id} draggableId={`${i.id}`} index={index}>\n                                            {(provided2) => <TaskCard forwardRBDProvided={provided2} task={i} />}\n                                        </Draggable>\n                                    ) : (\n                                        \"\"\n                                    )\n                                )}\n                                {provided.placeholder}\n                            </div>\n                        )}\n                    </Droppable>\n                </DragDropContext>\n\n                <DoneTasksDivider />\n\n                {tasks.map((i, index) => (i.isCompleted ? <TaskCard forwardRBDProvided={{ innerRef: null }} task={i} /> : \"\"))}\n            </Flipper>\n        </TaskBoardContainer>\n    );\n}\n","/home/pg07codes/Desktop/fokus/src/index.js",[],"/home/pg07codes/Desktop/fokus/src/helpers/index.js",["66","67"],"export function formattedTimeString(x) {\n    let secs = x % 60;\n    let mins = Math.floor(x / 60);\n\n    if (secs == 0) {\n        secs = `00`;\n    } else if (secs < 10) {\n        secs = `0${secs}`;\n    }\n    if (mins == 0) {\n        mins = `00`;\n    } else if (mins < 10) {\n        mins = `0${mins}`;\n    }\n\n    return `${mins}:${secs}`;\n}\n\n","/home/pg07codes/Desktop/fokus/src/store/index.js",[],["68","69"],{"ruleId":"70","severity":1,"message":"71","line":1,"column":17,"nodeType":"72","messageId":"73","endLine":1,"endColumn":25},{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","severity":1,"message":"79","line":15,"column":52,"nodeType":"80","messageId":"81","endLine":15,"endColumn":54},{"ruleId":"78","severity":1,"message":"79","line":22,"column":64,"nodeType":"80","messageId":"81","endLine":22,"endColumn":66},{"ruleId":"78","severity":1,"message":"82","line":120,"column":56,"nodeType":"80","messageId":"81","endLine":120,"endColumn":58},{"ruleId":"78","severity":1,"message":"82","line":166,"column":54,"nodeType":"80","messageId":"81","endLine":166,"endColumn":56},{"ruleId":"70","severity":1,"message":"83","line":3,"column":37,"nodeType":"72","messageId":"73","endLine":3,"endColumn":42},{"ruleId":"70","severity":1,"message":"84","line":9,"column":10,"nodeType":"72","messageId":"73","endLine":9,"endColumn":17},{"ruleId":"70","severity":1,"message":"85","line":206,"column":17,"nodeType":"72","messageId":"73","endLine":206,"endColumn":21},{"ruleId":"74","replacedBy":"86"},{"ruleId":"76","replacedBy":"87"},{"ruleId":"78","severity":1,"message":"79","line":92,"column":18,"nodeType":"80","messageId":"81","endLine":92,"endColumn":20},{"ruleId":"78","severity":1,"message":"82","line":100,"column":19,"nodeType":"80","messageId":"81","endLine":100,"endColumn":21},{"ruleId":"78","severity":1,"message":"82","line":5,"column":14,"nodeType":"80","messageId":"81","endLine":5,"endColumn":16},{"ruleId":"78","severity":1,"message":"82","line":10,"column":14,"nodeType":"80","messageId":"81","endLine":10,"endColumn":16},{"ruleId":"74","replacedBy":"88"},{"ruleId":"76","replacedBy":"89"},"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","no-native-reassign",["90"],"no-negated-in-lhs",["91"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","'reset' is defined but never used.","'ImLoop2' is defined but never used.","'time' is assigned a value but never used.",["90"],["91"],["90"],["91"],"no-global-assign","no-unsafe-negation"]