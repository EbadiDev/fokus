[{"/home/pg07codes/Desktop/fokus/src/containers/tasks/TaskCard.js":"1","/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js":"2","/home/pg07codes/Desktop/fokus/src/containers/tasks/index.js":"3","/home/pg07codes/Desktop/fokus/src/containers/App.js":"4","/home/pg07codes/Desktop/fokus/src/containers/tasks/tasksSlice.js":"5","/home/pg07codes/Desktop/fokus/src/serviceWorker.js":"6","/home/pg07codes/Desktop/fokus/src/containers/counter/counterSlice.js":"7","/home/pg07codes/Desktop/fokus/src/index.js":"8","/home/pg07codes/Desktop/fokus/src/store/index.js":"9","/home/pg07codes/Desktop/fokus/src/containers/focusBoard/index.js":"10","/home/pg07codes/Desktop/fokus/src/containers/focusBoard/focusBoardSlice.js":"11"},{"size":8538,"mtime":1612113063488,"results":"12","hashOfConfig":"13"},{"size":528,"mtime":1611252515979,"results":"14","hashOfConfig":"13"},{"size":4253,"mtime":1612112664368,"results":"15","hashOfConfig":"13"},{"size":381,"mtime":1612074872082,"results":"16","hashOfConfig":"13"},{"size":6574,"mtime":1612007098709,"results":"17","hashOfConfig":"13"},{"size":5141,"mtime":1608877484447,"results":"18","hashOfConfig":"13"},{"size":1552,"mtime":1608881410941,"results":"19","hashOfConfig":"13"},{"size":651,"mtime":1608902523877,"results":"20","hashOfConfig":"13"},{"size":307,"mtime":1611907004672,"results":"21","hashOfConfig":"13"},{"size":797,"mtime":1612086011055,"results":"22","hashOfConfig":"13"},{"size":392,"mtime":1612079700847,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26"},"g1paqb",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/pg07codes/Desktop/fokus/src/containers/tasks/TaskCard.js",["51","52"],"import React, { useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { remove, update, tick, reset, toggleIsRunning, toggleIsCompleted, rearrange } from \"./tasksSlice\";\nimport { focusOnTask } from \"./../focusBoard/focusBoardSlice\";\nimport useTimer from \"../../hooks/useTimer\";\nimport styled from \"styled-components\";\nimport { AiOutlineClockCircle } from \"react-icons/ai\";\nimport { BsCheckCircle } from \"react-icons/bs\";\nimport { FiClock } from \"react-icons/fi\";\nimport { ImLoop2, ImCancelCircle } from \"react-icons/im\";\nimport { Flipped } from \"react-flip-toolkit\";\nimport { GrDrag } from \"react-icons/gr\";\n\nfunction formattedTimeString(x) {\n    let seconds = x % 60;\n    let minutes = Math.floor(x / 60);\n\n    if (seconds == 0) {\n        seconds = `00`;\n    } else if (seconds < 10) {\n        seconds = `0${seconds}`;\n    }\n    if (minutes == 0) {\n        minutes = `00`;\n    } else if (minutes < 10) {\n        minutes = `0${minutes}`;\n    }\n\n    return `${minutes}:${seconds}`;\n}\n\nconst TaskCardContainer = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n    width: 576px;\n    height: 140px;\n    margin: 15px;\n    /* background-color: #fff4e1; */\n`;\n\nconst TaskCardDragIcon = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n    width: 30px;\n    height: 100%;\n    /* background-color: #ff09ac; */\n    svg {\n        cursor: url(\"https://ssl.gstatic.com/ui/v1/icons/mail/images/2/openhand.cur\"), default !important;\n        font-size: 2em;\n        opacity: 0.6;\n    }\n`;\n\nconst TaskCardDiv = styled.div`\n    display: flex;\n    justify-content: space-around;\n    flex-direction: row;\n    height: 100%;\n    width: 520px;\n    border-radius: 5px;\n    box-shadow: 0 4px 4px rgba(0, 0, 0, 0.2);\n    background: #fff;\n    border: 2px solid black;\n`;\n\nconst TaskDetailsDiv = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: space-around;\n    height: 100%;\n    width: 75%;\n    margin: 0 0 0 10px;\n    /* background-color: #fffcec; */\n    h3,\n    p {\n        margin: 5px 0 15px 0;\n    }\n`;\n\nconst TaskContentDiv = styled.div`\n    display: flex;\n    align-items: center;\n    height: 65%;\n    margin: 0 0 0 5px;\n    /* background-color: #fffcec; */\n    h3,\n    p {\n        margin: 5px 0 15px 0;\n    }\n`;\n\nconst TaskTimerDiv = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    height: 80%;\n    width: 20%;\n    /* background-color: #f8f8ff; */\n    position: relative;\n    p {\n        margin: 5px;\n        font-size: 1em;\n    }\n    svg {\n        font-size: 2.5em;\n        margin-top: 15px;\n    }\n`;\nconst TaskTimeDiv = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    height: 80%;\n    width: 120px;\n`;\nconst TaskTimeButton = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    width: 85px;\n    border-radius: 5px;\n    border: 1px solid black;\n    margin: 5px;\n    cursor: pointer;\n    background-color: #fff;\n    color: #000;\n    p {\n        margin: 0;\n        font-size: 0.7em;\n    }\n`;\n\nconst TaskDoneButton = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    height: 80%;\n    width: 70px;\n    border-radius: 5px;\n    border: 1px solid black;\n    margin: 5px;\n    cursor: pointer;\n    background-color: ${(props) => (props.isCompleted ? \"#000\" : \"#fff\")};\n    color: ${(props) => (props.isCompleted ? \"#fff\" : \"#000\")};\n    p {\n        margin: 0;\n        font-size: 0.7em;\n    }\n`;\n\nconst TaskDeleteButton = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    height: 80%;\n    width: 80px;\n    border-radius: 5px;\n    border: 1px solid black;\n    margin: 5px;\n    cursor: pointer;\n    background-color: #fff;\n    margin-left: auto;\n    color: #000;\n    p {\n        margin: 0;\n        font-size: 0.7em;\n    }\n    &:hover {\n        background-color: #000;\n        color: #fff;\n    }\n`;\n\nconst TaskControllerDiv = styled.div`\n    display: flex;\n    justify-content: flex-start;\n    align-items: center;\n    height: 25%;\n    /* background-color: #fffa91; */\n    svg {\n        font-size: 20px;\n        margin: 5px;\n    }\n`;\n\nfunction previewTask(str) {\n    if (str.length <= 70) return str;\n    else return str.substring(0, 70) + \"...\";\n}\n\nexport default function TaskCard({ task, forwardRBDProvided }) {\n    const delay = 1000;\n    const dispatch = useDispatch();\n    useTimer(\n        () => {\n            if (task.remainingTime > 0) {\n                dispatch(tick(task.id));\n            } else if (task.remainingTime === 0) {\n                dispatch(toggleIsRunning(task.id));\n            }\n        },\n        task.isRunning ? delay : null\n    );\n\n    const [taskEdit, setTaskEdit] = useState(false);\n    const [updatedTask, setUpdatedTask] = useState(task.content);\n    const [showDragIcon, setShowDragIcon] = useState(false);\n\n    return (\n        <Flipped flipId={`${task.id}`}>\n            <TaskCardContainer\n                ref={forwardRBDProvided.innerRef}\n                {...forwardRBDProvided.draggableProps}\n                {...forwardRBDProvided.dragHandleProps}\n                onMouseEnter={() => setShowDragIcon(true)}\n                onMouseLeave={() => setShowDragIcon(false)}\n            >\n                <TaskCardDragIcon>{showDragIcon && <GrDrag />}</TaskCardDragIcon>\n\n                <TaskCardDiv onClick={() => dispatch(focusOnTask(task))}>\n                    <TaskTimerDiv>\n                        <FiClock onClick={() => dispatch(toggleIsRunning(task.id))} />\n                        <p>{formattedTimeString(task.remainingTime)}</p>\n                    </TaskTimerDiv>\n\n                    <TaskDetailsDiv>\n                        <TaskContentDiv>\n                            {taskEdit ? (\n                                <input\n                                    value={updatedTask}\n                                    onBlur={() => {\n                                        dispatch(update({ id: task.id, updatedTask }));\n                                        setTaskEdit(false);\n                                    }}\n                                    onChange={(e) => setUpdatedTask(e.target.value)}\n                                />\n                            ) : (\n                                <h3 onDoubleClick={() => setTaskEdit(true)}>{previewTask(task.content)}</h3>\n                            )}\n                        </TaskContentDiv>\n\n                        <TaskControllerDiv>\n                            <TaskDoneButton\n                                isCompleted={task.isCompleted}\n                                onClick={\n                                    task.isCompleted\n                                        ? () => {\n                                              dispatch(toggleIsCompleted(task.id));\n                                              dispatch(rearrange({ id: task.id, markedAsComplete: false }));\n                                          }\n                                        : () => {\n                                              dispatch(toggleIsCompleted(task.id));\n                                              dispatch(rearrange({ id: task.id, markedAsComplete: true }));\n                                          }\n                                }\n                            >\n                                <BsCheckCircle />\n                                <p>Done</p>\n                            </TaskDoneButton>\n                            <TaskTimeDiv>\n                                <TaskTimeButton>\n                                    <AiOutlineClockCircle />\n                                    <p>{Math.round(task.time / 60) + \"mins\"}</p>\n                                </TaskTimeButton>\n                                <ImLoop2 onClick={() => dispatch(reset(task.id))} />\n                            </TaskTimeDiv>\n\n                            <TaskDeleteButton onClick={() => dispatch(remove(task.id))}>\n                                <ImCancelCircle />\n                                <p>Delete</p>\n                            </TaskDeleteButton>\n                        </TaskControllerDiv>\n                    </TaskDetailsDiv>\n                </TaskCardDiv>\n            </TaskCardContainer>\n        </Flipped>\n    );\n}\n","/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js",[],"/home/pg07codes/Desktop/fokus/src/containers/tasks/index.js",["53","54"],"import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { create, updateOrder, incrementGlobalKey } from \"./tasksSlice\";\nimport TaskCard from \"./TaskCard\";\nimport { DragDropContext, Draggable, Droppable } from \"react-beautiful-dnd\";\nimport { Flipper } from \"react-flip-toolkit\";\nimport styled from \"styled-components\";\n\nconst TaskInputContainer = styled.div`\n    display: flex;\n    justify-content: space-around;\n    align-items: center;\n    margin: 20px auto;\n    width: 600px;\n    background-color: #f8f8ff;\n    border-radius: 15px;\n    height: 75px;\n`;\n\nconst TaskInputField = styled.input`\n    height: 50px;\n    width: 90%;\n    font-size: 0.9rem;\n    border: 0;\n    outline: none;\n    border-radius: 15px;\n    background-color: #f8f8ff;\n`;\n\nexport function Task() {\n    const tasks = useSelector((state) => state.tasks.taskArray);\n    const meta = useSelector((state) => state.tasks.meta);\n    const dispatch = useDispatch();\n\n    const [task, setTask] = useState(\"\");\n\n    function submitTask(e) {\n        if (e.key === \"Enter\" && task.trim().length > 2) {\n            let temp = task.trim().split(\" \");\n            let time = 0;\n            if (!isNaN(parseInt(temp[temp.length - 1]))) {\n                time = parseInt(temp.pop());\n            } else {\n                time = 20;\n            }\n            temp = temp.join(\" \");\n\n            let newTask = {\n                id: Math.floor(Math.random() * 10000),\n                globalKey: meta.globalKey,\n                content: temp,\n                time: time * 60,\n                remainingTime: time * 60,\n                isRunning: false,\n                isCompleted: false,\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString(),\n            };\n            dispatch(create(newTask));\n            dispatch(incrementGlobalKey());\n            setTask(\"\");\n            e.target.value = \"\";\n            e.target.focus();\n        }\n    }\n\n    function handleOnDragEnd(result) {\n        if (!result.destination) return;\n\n        let items = [...tasks.map((i) => ({ ...i }))];\n        //let items = [...tasks]\n        // let x = JSON.stringify(items);\n        // items = JSON.parse(x);\n\n        const [reorderedItem] = items.splice(result.source.index, 1);\n        items.splice(result.destination.index, 0, reorderedItem);\n\n        let i = result.source.index;\n        let direction = result.destination.index > result.source.index; // direction true means moving right & swapping\n        while (i != result.destination.index) {\n            if (direction) {\n                items[i].globalKey = tasks[i].globalKey;\n                i++;\n            } else {\n                items[i].globalKey = tasks[i].globalKey;\n                i--;\n            }\n            if (i == result.destination.index) {\n                items[i].globalKey = tasks[i].globalKey;\n            }\n        }\n\n        dispatch(updateOrder(items));\n    }\n\n    function getFlipKey() {\n        let flipKey = \"\";\n        tasks.forEach((i) => {\n            flipKey += `${i.globalKey}`;\n        });\n        return flipKey;\n    }\n\n    return (\n        <div style={{ flex: \"3 1 0\"}}>\n            <TaskInputContainer>\n                <TaskInputField type=\"text\" onChange={(e) => setTask(e.target.value)} onKeyDown={submitTask} />\n            </TaskInputContainer>\n            <DragDropContext onDragEnd={handleOnDragEnd}>\n                <Droppable droppableId=\"dropArea\">\n                    {(provided) => (\n                        <div {...provided.droppableProps} ref={provided.innerRef}>\n                            <Flipper flipKey={getFlipKey()}>\n                                {tasks.map((i, index) => (\n                                    <Draggable key={i.id} draggableId={`${i.id}`} index={index}>\n                                        {(provided2) => <TaskCard forwardRBDProvided={provided2} task={i} />}\n                                    </Draggable>\n                                ))}\n                                {provided.placeholder}\n                            </Flipper>\n                        </div>\n                    )}\n                </Droppable>\n            </DragDropContext>\n        </div>\n    );\n}\n","/home/pg07codes/Desktop/fokus/src/containers/App.js",[],"/home/pg07codes/Desktop/fokus/src/containers/tasks/tasksSlice.js",["55","56","57","58"],"import { createSlice } from \"@reduxjs/toolkit\";\n\nexport const tasksSlice = createSlice({\n    name: \"tasks\",\n    initialState: {\n        taskArray: [],\n        meta: {\n            globalKey: 0,\n            completedTaskStartIndex: -1,\n        },\n    },\n    reducers: {\n        create: (tasks, { payload }) => {\n            tasks.taskArray.unshift(payload);\n            if (tasks.meta.completedTaskStartIndex != -1) ++tasks.meta.completedTaskStartIndex;\n        },\n        remove: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.filter((i) => {\n                if (i.id !== payload) return true;\n                else {\n                    if (!i.isCompleted) {\n                        if (tasks.meta.completedTaskStartIndex != -1) --tasks.meta.completedTaskStartIndex;\n                    }\n                    return false;\n                }\n            });\n        },\n        update: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    i.content = payload.updatedTask;\n                }\n            });\n        },\n        updateOrder: (tasks, { payload }) => {\n            tasks.taskArray = payload;\n        },\n        tick: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    i.remainingTime = i.remainingTime - 1;\n                }\n            });\n        },\n        reset: ({taskArray}, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    i.remainingTime = i.time;\n                    i.isRunning = false;\n                }\n            });\n        },\n        toggleIsRunning: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    i.isRunning = !i.isRunning;\n                }\n            });\n        },\n        toggleIsCompleted: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    i.isCompleted = !i.isCompleted;\n                }\n            });\n        },\n        incrementGlobalKey: ({ meta }) => {\n            ++meta.globalKey;\n        },\n        rearrange: (tasks, { payload }) => {\n            let id = payload.id;\n\n            if (payload.markedAsComplete) {\n                if (tasks.meta.completedTaskStartIndex === -1) {\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                    let found = false;\n                    for (let i = 0; i < tasks.taskArray.length - 1; i++) {\n                        if(found){\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        }else if(tasks.taskArray[i].id === id){\n                            found=true;\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        }\n                    }\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                } else {\n                    let task, idx;\n                    for (let i = 0; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n                    let pos = -1;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].globalKey > task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n                    \n                    if (pos === -1) {\n                        tasks.taskArray.push(task);\n                    } else {\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.meta.completedTaskStartIndex -=1;\n                }\n            } else {\n                if (tasks.meta.completedTaskStartIndex == 0) {\n\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.taskArray.unshift(task);\n                    tasks.meta.completedTaskStartIndex = 1;\n                } else {\n\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    let start = tasks.meta.completedTaskStartIndex - 1;\n                    let pos = -1;\n                    for (let i = start; i >= 0; i--) {\n                        if (tasks.taskArray[i].globalKey < task.globalKey ) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    if (pos === -1) {\n                        tasks.taskArray.unshift(task);\n                    } else {\n                        pos++;\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.meta.completedTaskStartIndex += 1;\n\n                }\n\n                if(tasks.meta.completedTaskStartIndex==tasks.taskArray.length){\n                    tasks.meta.completedTaskStartIndex=-1;\n                }\n            }\n        },\n    },\n});\n\nexport const { create, remove, update, reset, toggleIsRunning, tick, toggleIsCompleted, updateOrder, incrementGlobalKey, rearrange } = tasksSlice.actions;\n\nexport default tasksSlice.reducer;\n","/home/pg07codes/Desktop/fokus/src/serviceWorker.js",[],["59","60"],"/home/pg07codes/Desktop/fokus/src/containers/counter/counterSlice.js",[],"/home/pg07codes/Desktop/fokus/src/index.js",[],["61","62"],"/home/pg07codes/Desktop/fokus/src/store/index.js",[],"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/index.js",["63","64","65"],"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/focusBoardSlice.js",[],{"ruleId":"66","severity":1,"message":"67","line":18,"column":17,"nodeType":"68","messageId":"69","endLine":18,"endColumn":19},{"ruleId":"66","severity":1,"message":"67","line":23,"column":17,"nodeType":"68","messageId":"69","endLine":23,"endColumn":19},{"ruleId":"66","severity":1,"message":"70","line":80,"column":18,"nodeType":"68","messageId":"69","endLine":80,"endColumn":20},{"ruleId":"66","severity":1,"message":"67","line":88,"column":19,"nodeType":"68","messageId":"69","endLine":88,"endColumn":21},{"ruleId":"66","severity":1,"message":"70","line":15,"column":52,"nodeType":"68","messageId":"69","endLine":15,"endColumn":54},{"ruleId":"66","severity":1,"message":"70","line":22,"column":64,"nodeType":"68","messageId":"69","endLine":22,"endColumn":66},{"ruleId":"66","severity":1,"message":"67","line":117,"column":56,"nodeType":"68","messageId":"69","endLine":117,"endColumn":58},{"ruleId":"66","severity":1,"message":"67","line":163,"column":54,"nodeType":"68","messageId":"69","endLine":163,"endColumn":56},{"ruleId":"71","replacedBy":"72"},{"ruleId":"73","replacedBy":"74"},{"ruleId":"71","replacedBy":"75"},{"ruleId":"73","replacedBy":"76"},{"ruleId":"77","severity":1,"message":"78","line":6,"column":11,"nodeType":"79","messageId":"80","endLine":6,"endColumn":19},{"ruleId":"77","severity":1,"message":"81","line":8,"column":12,"nodeType":"79","messageId":"80","endLine":8,"endColumn":21},{"ruleId":"77","severity":1,"message":"82","line":8,"column":23,"nodeType":"79","messageId":"80","endLine":8,"endColumn":35},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-native-reassign",["83"],"no-negated-in-lhs",["84"],["83"],["84"],"no-unused-vars","'dispatch' is assigned a value but never used.","Identifier","unusedVar","'isFocusON' is assigned a value but never used.","'setIsFocusON' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]