[{"/home/pg07codes/Desktop/fokus/src/containers/menu/Menu.js":"1","/home/pg07codes/Desktop/fokus/src/containers/focusBoard/FocusBoard.js":"2","/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js":"3","/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskCard.js":"4","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/taskBoardSlice.js":"5","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/TaskBoard.js":"6","/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskInput.js":"7","/home/pg07codes/Desktop/fokus/src/components/TaskBoard/Divider.js":"8","/home/pg07codes/Desktop/fokus/src/index.js":"9","/home/pg07codes/Desktop/fokus/src/helpers/index.js":"10"},{"size":328,"mtime":1612977328497,"results":"11","hashOfConfig":"12"},{"size":8795,"mtime":1612983616196,"results":"13","hashOfConfig":"12"},{"size":528,"mtime":1611252515979,"results":"14","hashOfConfig":"12"},{"size":11895,"mtime":1612980822655,"results":"15","hashOfConfig":"12"},{"size":8753,"mtime":1612979276017,"results":"16","hashOfConfig":"12"},{"size":5942,"mtime":1612980556119,"results":"17","hashOfConfig":"12"},{"size":4298,"mtime":1612959925708,"results":"18","hashOfConfig":"12"},{"size":2620,"mtime":1612951496639,"results":"19","hashOfConfig":"12"},{"size":651,"mtime":1608902523877,"results":"20","hashOfConfig":"12"},{"size":684,"mtime":1612960710174,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"g1paqb",{"filePath":"24","messages":"25","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"32","messages":"33","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/pg07codes/Desktop/fokus/src/containers/menu/Menu.js",[],"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/FocusBoard.js",["46"],"import React from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport styled from \"styled-components\";\nimport { toggleIsRunning, resetTaskTimer, tick, updateTaskTimeByVal } from \"../taskBoard/taskBoardSlice\";\nimport useTimer from \"../../hooks/useTimer\";\nimport { formattedTimeStringv2 } from \"../../helpers\";\nimport { CircularProgressbarWithChildren, buildStyles } from \"react-circular-progressbar\";\nimport \"react-circular-progressbar/dist/styles.css\";\nimport { BsFillPlayFill, BsFillPauseFill } from \"react-icons/bs\";\nimport { ImLoop2 } from \"react-icons/im\";\nimport dingSound from \"./../../sounds/ding.mp3\";\nimport tasks from \"./../../images/tasks.svg\";\nimport { CgNotes } from \"react-icons/cg\";\n\nlet dingSoundElement = new Audio(dingSound);\n\nconst FocusBoardContainer = styled.div`\n    flex: 3 1 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    border-right: 2px black solid;\n`;\n\nconst FocussedTaskContainer = styled.div`\n    display: flex;\n    justify-content: center;\n    position: relative;\n    width: 276px;\n    height: 346px;\n    margin: 20px;\n    border-radius: 10px;\n    box-shadow: 0 2px 10px rgba(166, 173, 201, 0.5);\n    -webkit-box-shadow: 0 2px 10px rgba(166, 173, 201, 0.5);\n    background-color: #f7f7fa;\n`;\n\nconst FocussedTaskDiv = styled.div`\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n    width: 100%;\n    height: 100%;\n`;\n\nconst FocussedTaskTimer = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    height: 50%;\n`;\n\nconst CountdownTimerDiv = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    width: 90px;\n    height: 90px;\n    background-color: #fff;\n    -webkit-box-shadow: 0 2px 10px rgba(166, 173, 201, 0.2);\n    box-shadow: 0 2px 10px rgba(166, 173, 201, 0.2);\n    border-radius: 50%;\n    & > p {\n        font-size: 0.9em;\n        font-weight: bold;\n        color: ${(p) => (p.isDisabled ? \"#c1c1d7\" : \"#000\")};\n    }\n`;\n\nconst PlayButtonDiv = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 55px;\n    height: 55px;\n    background-color: #0000cd;\n    border-radius: 50%;\n    margin: 10px 20px;\n    box-shadow: 0 1px 7px rgba(0, 0, 0, 0.4);\n    -webkit-box-shadow: 0 1px 7px rgba(0, 0, 0, 0.4);\n    svg {\n        color: #fff;\n        font-size: 1.8em;\n    }\n    cursor: pointer;\n`;\n\nconst UpdateTimeButtonDiv = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 30px;\n    height: 30px;\n    cursor: pointer;\n`;\n\nconst ResetButtonDiv = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    position: absolute;\n    background-color: ${(p) => (p.isDisabled ? \"#c1c1d7\" : \"#0000cd\")};\n    border-radius: 50%;\n    width: 30px;\n    height: 30px;\n    top: 7px;\n    right: 7px;\n    cursor: pointer;\n    svg {\n        color: #fff;\n        font-size: 0.6em;\n    }\n`;\n\nconst FocussedTaskContent = styled.div`\n    display: flex;\n    justify-content: center;\n    text-align: center;\n    margin: 5px;\n    height: 30%;\n    width: 90%;\n    word-wrap: break-word;\n    p {\n        min-width: 0;\n        font-weight: bold;\n        margin: 3px;\n    }\n`;\n\nconst FocussedTaskController = styled.div`\n    display: flex;\n    justify-content: space-evenly;\n    align-items: center;\n    height: 20%;\n    margin-bottom: 10px;\n`;\n\nconst EmptyFocusBox = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-direction: column;\n    width: 100%;\n    height: 100%;\n`;\n\nconst NotesIconDiv = styled.div`\n    svg{\n        font-size:80px;\n        color:#c1c1d7\n    }\n`;\nconst EmptyFocusBoxText = styled.div`\n    display: flex;\n    justify-content: center;\n    text-align: center;\n    margin: 10px;\n    height: 15%;\n    width: 90%;\n    p {\n        margin-bottom: 10px;\n        display: inline-block;\n        font-weight: bold;\n        color: #c1c1d7;\n    }\n`;\n\nexport function FocusBoard() {\n    const focussedTaskIndex = useSelector((state) => state.tasks.meta.focussedTaskIndex);\n    let focussedTask = useSelector((state) => (focussedTaskIndex !== -1 ? state.tasks.taskArray[focussedTaskIndex] : null));\n    const dispatch = useDispatch();\n    const delay = 1000;\n    useTimer(\n        () => {\n            if (focussedTask === null) return;\n            else if (focussedTask.remainingTime > 0) {\n                dispatch(tick(focussedTaskIndex));\n            } else if (focussedTask.remainingTime === 0) {\n                dispatch(toggleIsRunning({ idx: focussedTaskIndex }));\n                dingSoundElement.play();\n            }\n        },\n        focussedTask !== null && focussedTask.isRunning ? delay : null\n    );\n\n    function updateTaskTimeHandler(val) {\n        if (focussedTask.isCompleted) return;\n        if (focussedTask.isRunning) dispatch(toggleIsRunning({ idx: focussedTaskIndex }));\n        dispatch(updateTaskTimeByVal({ focussedTaskIndex, val }));\n    }\n\n    return (\n        <FocusBoardContainer>\n            <FocussedTaskContainer>\n                {focussedTask != null && (\n                    <FocussedTaskDiv>\n                        <FocussedTaskTimer>\n                            <div style={{ width: 120, height: 120 }}>\n                                <CircularProgressbarWithChildren\n                                    value={focussedTask.time !== 0 ? Math.floor((focussedTask.remainingTime / focussedTask.time) * 100) : 0}\n                                    styles={buildStyles({\n                                        strokeLinecap: \"butt\",\n\n                                        pathColor: \"#0000cd\",\n                                        trailColor: \"#EFF7FF\",\n                                    })}\n                                    strokeWidth={6}\n                                >\n                                    <CountdownTimerDiv>\n                                        <p>{formattedTimeStringv2(focussedTask.remainingTime)}</p>\n                                    </CountdownTimerDiv>\n                                </CircularProgressbarWithChildren>\n                            </div>\n                        </FocussedTaskTimer>\n                        <FocussedTaskContent>\n                            <p>{focussedTask.content}</p>\n                        </FocussedTaskContent>\n                        <FocussedTaskController>\n                            <UpdateTimeButtonDiv onClick={() => updateTaskTimeHandler(-5)}>\n                                <h4>-5</h4>\n                            </UpdateTimeButtonDiv>\n                            <PlayButtonDiv onClick={() => dispatch(toggleIsRunning({ idx: focussedTaskIndex }))}>\n                                {focussedTask.isRunning ? <BsFillPauseFill /> : <BsFillPlayFill />}\n                            </PlayButtonDiv>\n\n                            <UpdateTimeButtonDiv onClick={() => updateTaskTimeHandler(5)}>\n                                <h4>+5</h4>\n                            </UpdateTimeButtonDiv>\n                        </FocussedTaskController>\n                        <ResetButtonDiv onClick={() => dispatch(resetTaskTimer(focussedTaskIndex))}>\n                            <ImLoop2 />\n                        </ResetButtonDiv>\n                    </FocussedTaskDiv>\n                )}\n                {focussedTask === null && (\n                    <EmptyFocusBox>\n                        <FocussedTaskTimer>\n                            <div style={{ width: 120, height: 120 }}>\n                                <CircularProgressbarWithChildren\n                                    value={100}\n                                    styles={buildStyles({\n                                        pathColor: \"#c1c1d7\",\n                                    })}\n                                    strokeWidth={6}\n                                >\n                                    <CountdownTimerDiv isDisabled={true}>\n                                        <p>{\"20m 00s\"}</p>\n                                    </CountdownTimerDiv>\n                                </CircularProgressbarWithChildren>\n                            </div>\n                        </FocussedTaskTimer>\n\n                        <NotesIconDiv>\n                            <CgNotes />\n                        </NotesIconDiv>\n\n                        <EmptyFocusBoxText>\n                            <p>Choose a task to focus on</p>\n                        </EmptyFocusBoxText>\n                        <ResetButtonDiv isDisabled={true}>\n                            <ImLoop2 />\n                        </ResetButtonDiv>\n                    </EmptyFocusBox>\n                )}\n            </FocussedTaskContainer>\n        </FocusBoardContainer>\n    );\n}\n",["47","48"],"/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js",[],"/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskCard.js",["49"],"/home/pg07codes/Desktop/fokus/src/containers/taskBoard/taskBoardSlice.js",["50","51","52","53","54"],"import { createSlice } from \"@reduxjs/toolkit\";\n\nexport const tasksSlice = createSlice({\n    name: \"tasks\",\n    initialState: {\n        taskArray: [],\n        meta: {\n            globalKey: 0,\n            completedTaskStartIndex: -1,\n            focussedTaskIndex: -1,\n            showCompletedTasks: true,\n            completedTasksCount: 0,\n        },\n    },\n    reducers: {\n        create: (tasks, { payload }) => {\n            tasks.taskArray.unshift(payload);\n            if (tasks.meta.completedTaskStartIndex != -1) ++tasks.meta.completedTaskStartIndex;\n        },\n        remove: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.filter((i) => {\n                if (i.id !== payload) return true;\n                else {\n                    if (!i.isCompleted) {\n                        if (tasks.meta.completedTaskStartIndex != -1) --tasks.meta.completedTaskStartIndex;\n                    } else if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length - 1) {\n                        tasks.meta.completedTasksCount--;\n                        tasks.meta.completedTaskStartIndex = -1;\n                    }\n                    return false;\n                }\n            });\n        },\n        updateTask: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.map((i) => (i.id === payload.id ? payload : i));\n        },\n        updateTaskContent: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    i.content = payload.updatedTaskContent;\n                }\n            });\n        },\n        updateTaskTime: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    i.remainingTime = payload.updatedTime * 60;\n                    i.time = payload.updatedTime * 60;\n                }\n            });\n        },\n        updateTaskTimeByVal: (tasks, { payload }) => {\n            tasks.taskArray[payload.focussedTaskIndex].remainingTime += payload.val * 60;\n            tasks.taskArray[payload.focussedTaskIndex].time += payload.val * 60;\n            if (tasks.taskArray[payload.focussedTaskIndex].remainingTime < 0) {\n                tasks.taskArray[payload.focussedTaskIndex].remainingTime = 0;\n            }\n            if (tasks.taskArray[payload.focussedTaskIndex].time < 0) {\n                tasks.taskArray[payload.focussedTaskIndex].time = 0;\n            }\n        },\n        updateOrder: (tasks, { payload }) => {\n            tasks.taskArray = payload;\n        },\n\n        focusOnTask: (tasks, { payload }) => {\n            tasks.meta.focussedTaskIndex = payload;\n        },\n        resetFocussedTask: (tasks) => {\n            tasks.meta.focussedTaskIndex = -1;\n        },\n        tick: (tasks, { payload }) => {\n            --tasks.taskArray[payload].remainingTime;\n        },\n        resetTaskTimer: (tasks, { payload }) => {\n            tasks.taskArray[payload].isRunning = false;\n            tasks.taskArray[payload].remainingTime = tasks.taskArray[payload].time;\n        },\n        toggleIsRunning: (tasks, { payload }) => {\n            if (payload.val !== undefined) tasks.taskArray[payload.idx].isRunning = payload.val;\n            else tasks.taskArray[payload.idx].isRunning = !tasks.taskArray[payload.idx].isRunning;\n        },\n        toggleShowCompletedTasks: (tasks) => {\n            tasks.meta.showCompletedTasks = !tasks.meta.showCompletedTasks;\n        },\n        toggleIsCompleted: (tasks, { payload }) => {\n            tasks.taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    i.isCompleted ? --tasks.meta.completedTasksCount : ++tasks.meta.completedTasksCount;\n                    i.isCompleted = !i.isCompleted;\n                }\n            });\n        },\n        clearCompletedTasks: (tasks) => {\n            if (tasks.meta.completedTaskStartIndex !== -1) {\n                tasks.taskArray.length = tasks.meta.completedTaskStartIndex;\n                tasks.meta.completedTaskStartIndex = -1;\n                tasks.meta.completedTasksCount = 0;\n            }\n        },\n        incrementGlobalKey: ({ meta }) => {\n            ++meta.globalKey;\n        },\n        rearrange: (tasks, { payload }) => {\n            let id = payload.id;\n\n            if (payload.markedAsComplete) {\n                if (tasks.meta.completedTaskStartIndex === -1) {\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                    let found = false;\n                    for (let i = 0; i < tasks.taskArray.length - 1; i++) {\n                        if (found) {\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        } else if (tasks.taskArray[i].id === id) {\n                            found = true;\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        }\n                    }\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                } else {\n                    let task, idx;\n                    for (let i = 0; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n                    let pos = -1;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].globalKey > task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    if (pos === -1) {\n                        tasks.taskArray.push(task);\n                    } else {\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.meta.completedTaskStartIndex -= 1;\n                }\n            } else {\n                if (tasks.meta.completedTaskStartIndex == 0) {\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.taskArray.unshift(task);\n                    tasks.meta.completedTaskStartIndex = 1;\n                } else {\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    let start = tasks.meta.completedTaskStartIndex - 1;\n                    let pos = -1;\n                    for (let i = start; i >= 0; i--) {\n                        if (tasks.taskArray[i].globalKey < task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    if (pos === -1) {\n                        tasks.taskArray.unshift(task);\n                    } else {\n                        pos++;\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.meta.completedTaskStartIndex += 1;\n                }\n\n                if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length) {\n                    tasks.meta.completedTaskStartIndex = -1;\n                }\n            }\n        },\n    },\n});\n\nexport const {\n    create,\n    remove,\n    updateTask,\n    updateTaskContent,\n    updateTaskTime,\n    updateTaskTimeByVal,\n    focusOnTask,\n    resetFocussedTask,\n    tick,\n    resetTaskTimer,\n    toggleIsRunning,\n    toggleShowCompletedTasks,\n    toggleIsCompleted,\n    clearCompletedTasks,\n    updateOrder,\n    incrementGlobalKey,\n    rearrange,\n} = tasksSlice.actions;\n\nexport default tasksSlice.reducer;\n","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/TaskBoard.js",["55","56","57"],"import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { updateOrder } from \"./taskBoardSlice\";\nimport TaskCard from \"./../../components/TaskBoard/TaskCard\";\nimport { DragDropContext, Draggable, Droppable } from \"react-beautiful-dnd\";\nimport { Flipper } from \"react-flip-toolkit\";\nimport { focusOnTask } from \"./taskBoardSlice\";\nimport styled from \"styled-components\";\nimport TaskInput from \"./../../components/TaskBoard/TaskInput\";\nimport Divider from \"./../../components/TaskBoard/Divider\";\n\nconst TaskBoardContainer = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background-color: #f7f7fa;\n    flex: 2 1 0;\n`;\n\nexport function TaskBoard() {\n    const tasks = useSelector((state) => state.tasks.taskArray);\n    const meta = useSelector((state) => state.tasks.meta);\n    let focussedTask = meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex] : null;\n    const dispatch = useDispatch();\n\n    function handleOnDragEnd(result) {\n        if (!result.destination) return;\n\n        let items = [...tasks.map((i) => ({ ...i }))];\n        const [reorderedItem] = items.splice(result.source.index, 1);\n        items.splice(result.destination.index, 0, reorderedItem);\n\n        let i = result.source.index;\n        let direction = result.destination.index > result.source.index; // direction true means moving right & swapping\n        // below is logic to reset globalKeys to maintain correct sort order.\n        while (i != result.destination.index) {\n            if (direction) {\n                items[i].globalKey = tasks[i].globalKey;\n                i++;\n            } else {\n                items[i].globalKey = tasks[i].globalKey;\n                i--;\n            }\n            if (i == result.destination.index) {\n                items[i].globalKey = tasks[i].globalKey;\n            }\n        }\n\n        if (meta.focussedTaskIndex !== -1) {\n            let greaterIndex = Math.max(result.destination.index, result.source.index);\n            let smallerIndex = Math.min(result.destination.index, result.source.index);\n\n            if (result.source.index === meta.focussedTaskIndex) {\n                dispatch(focusOnTask(result.destination.index));\n            } else if (meta.focussedTaskIndex >= smallerIndex && meta.focussedTaskIndex <= greaterIndex) {\n                if (result.destination.index > result.source.index) {\n                    dispatch(focusOnTask(meta.focussedTaskIndex - 1)); // -1\n                } else {\n                    dispatch(focusOnTask(meta.focussedTaskIndex + 1)); // +1\n                }\n            }\n        }\n\n        dispatch(updateOrder(items)); // order is imp. focus then updateOrder\n    }\n\n    function getFlipKey() {\n        let flipKey = \"\";\n        tasks.forEach((i) => {\n            flipKey += `${i.globalKey}`;\n        });\n        flipKey += `${meta.completedTaskStartIndex}`;\n        return flipKey;\n    }\n\n    function isFocussed(id) {\n        if (focussedTask !== null && focussedTask.id === id) return true;\n        return false;\n    }\n\n    // input has both onChange and onKeyDown - can be optimised by using one and combining\n\n    return (\n        <TaskBoardContainer>\n            <TaskInput focussedTaskIndex={meta.focussedTaskIndex} />\n\n            <Flipper flipKey={getFlipKey()}>\n                <DragDropContext onDragEnd={handleOnDragEnd}>\n                    <Droppable droppableId=\"dropArea\">\n                        {(provided) => (\n                            <div {...provided.droppableProps} ref={provided.innerRef}>\n                                {tasks.map((i, index) =>\n                                    !i.isCompleted ? (\n                                        <Draggable isDragDisabled={i.isCompleted} key={i.id} draggableId={`${i.id}`} index={index}>\n                                            {(provided2) => (\n                                                <TaskCard\n                                                    focussedTaskIndex={meta.focussedTaskIndex}\n                                                    focussedTaskGlobalKey={meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex].globalKey : -1}\n                                                    taskIndex={index}\n                                                    forwardRBDProvided={provided2}\n                                                    task={i}\n                                                    isFocussed={isFocussed(i.id)}\n                                                />\n                                            )}\n                                        </Draggable>\n                                    ) : (\n                                        \"\"\n                                    )\n                                )}\n                                {provided.placeholder}\n                            </div>\n                        )}\n                    </Droppable>\n                </DragDropContext>\n\n                {meta.completedTaskStartIndex !== -1 && meta.completedTaskStartIndex !== 0 && <Divider />}\n\n                {meta.showCompletedTasks &&\n                    tasks.map((i, index) =>\n                        i.isCompleted ? (\n                            <TaskCard\n                                focussedTaskIndex={meta.focussedTaskIndex}\n                                focussedTaskGlobalKey={meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex].globalKey : -1}\n                                taskIndex={index}\n                                key={i.id}\n                                forwardRBDProvided={{ innerRef: null }}\n                                task={i}\n                                isFocussed={isFocussed(i.id)}\n                            />\n                        ) : (\n                            \"\"\n                        )\n                    )}\n            </Flipper>\n        </TaskBoardContainer>\n    );\n}\n","/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskInput.js",[],"/home/pg07codes/Desktop/fokus/src/components/TaskBoard/Divider.js",[],"/home/pg07codes/Desktop/fokus/src/index.js",[],"/home/pg07codes/Desktop/fokus/src/helpers/index.js",["58","59","60","61"],{"ruleId":"62","severity":1,"message":"63","line":12,"column":8,"nodeType":"64","messageId":"65","endLine":12,"endColumn":13},{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","replacedBy":"69"},{"ruleId":"62","severity":1,"message":"70","line":184,"column":17,"nodeType":"64","messageId":"65","endLine":184,"endColumn":21},{"ruleId":"71","severity":1,"message":"72","line":18,"column":52,"nodeType":"73","messageId":"74","endLine":18,"endColumn":54},{"ruleId":"71","severity":1,"message":"72","line":25,"column":64,"nodeType":"73","messageId":"74","endLine":25,"endColumn":66},{"ruleId":"71","severity":1,"message":"75","line":26,"column":67,"nodeType":"73","messageId":"74","endLine":26,"endColumn":69},{"ruleId":"71","severity":1,"message":"75","line":151,"column":56,"nodeType":"73","messageId":"74","endLine":151,"endColumn":58},{"ruleId":"71","severity":1,"message":"75","line":194,"column":56,"nodeType":"73","messageId":"74","endLine":194,"endColumn":58},{"ruleId":"62","severity":1,"message":"76","line":1,"column":17,"nodeType":"64","messageId":"65","endLine":1,"endColumn":25},{"ruleId":"71","severity":1,"message":"72","line":36,"column":18,"nodeType":"73","messageId":"74","endLine":36,"endColumn":20},{"ruleId":"71","severity":1,"message":"75","line":44,"column":19,"nodeType":"73","messageId":"74","endLine":44,"endColumn":21},{"ruleId":"71","severity":1,"message":"75","line":5,"column":14,"nodeType":"73","messageId":"74","endLine":5,"endColumn":16},{"ruleId":"71","severity":1,"message":"75","line":10,"column":14,"nodeType":"73","messageId":"74","endLine":10,"endColumn":16},{"ruleId":"71","severity":1,"message":"75","line":23,"column":14,"nodeType":"73","messageId":"74","endLine":23,"endColumn":16},{"ruleId":"71","severity":1,"message":"75","line":28,"column":14,"nodeType":"73","messageId":"74","endLine":28,"endColumn":16},"no-unused-vars","'tasks' is defined but never used.","Identifier","unusedVar","no-native-reassign",["77"],"no-negated-in-lhs",["78"],"'temp' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","'useState' is defined but never used.","no-global-assign","no-unsafe-negation"]