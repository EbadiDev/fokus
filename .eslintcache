[{"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/focusBoardSlice.js":"1","/home/pg07codes/Desktop/fokus/src/containers/App.js":"2","/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js":"3","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/taskBoardSlice.js":"4","/home/pg07codes/Desktop/fokus/src/serviceWorker.js":"5","/home/pg07codes/Desktop/fokus/src/index.js":"6","/home/pg07codes/Desktop/fokus/src/helpers/index.js":"7","/home/pg07codes/Desktop/fokus/src/store/index.js":"8","/home/pg07codes/Desktop/fokus/src/containers/focusBoard/FocusBoard.js":"9","/home/pg07codes/Desktop/fokus/src/containers/taskBoard/TaskBoard.js":"10","/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskInput.js":"11","/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskCard.js":"12","/home/pg07codes/Desktop/fokus/src/components/customIcons/Globe.js":"13","/home/pg07codes/Desktop/fokus/src/components/TaskBoard/Divider.js":"14"},{"size":1343,"mtime":1612703422949,"results":"15","hashOfConfig":"16"},{"size":395,"mtime":1612199237429,"results":"17","hashOfConfig":"16"},{"size":528,"mtime":1611252515979,"results":"18","hashOfConfig":"16"},{"size":6994,"mtime":1612712164732,"results":"19","hashOfConfig":"16"},{"size":5141,"mtime":1608877484447,"results":"20","hashOfConfig":"16"},{"size":651,"mtime":1608902523877,"results":"21","hashOfConfig":"16"},{"size":340,"mtime":1612282841002,"results":"22","hashOfConfig":"16"},{"size":327,"mtime":1612199332055,"results":"23","hashOfConfig":"16"},{"size":5800,"mtime":1612713546264,"results":"24","hashOfConfig":"16"},{"size":4169,"mtime":1612711033850,"results":"25","hashOfConfig":"16"},{"size":3706,"mtime":1612681363200,"results":"26","hashOfConfig":"16"},{"size":9604,"mtime":1612713699844,"results":"27","hashOfConfig":"16"},{"size":576,"mtime":1612677540821,"results":"28","hashOfConfig":"16"},{"size":841,"mtime":1612678489978,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"g1paqb",{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"40"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"43"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/focusBoardSlice.js",[],"/home/pg07codes/Desktop/fokus/src/containers/App.js",[],["65","66"],"/home/pg07codes/Desktop/fokus/src/hooks/useTimer.js",[],"/home/pg07codes/Desktop/fokus/src/containers/taskBoard/taskBoardSlice.js",["67","68","69","70","71"],"import { createSlice } from \"@reduxjs/toolkit\";\n\nexport const tasksSlice = createSlice({\n    name: \"tasks\",\n    initialState: {\n        taskArray: [],\n        meta: {\n            globalKey: 0,\n            completedTaskStartIndex: -1,\n            focussedTaskIndex: -1,\n        },\n    },\n    reducers: {\n        create: (tasks, { payload }) => {\n            tasks.taskArray.unshift(payload);\n            if (tasks.meta.completedTaskStartIndex != -1) ++tasks.meta.completedTaskStartIndex;\n        },\n        remove: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.filter((i) => {\n                if (i.id !== payload) return true;\n                else {\n                    if (!i.isCompleted) {\n                        if (tasks.meta.completedTaskStartIndex != -1) --tasks.meta.completedTaskStartIndex;\n                    } else if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length - 1) {\n                        tasks.meta.completedTaskStartIndex = -1;\n                    }\n                    return false;\n                }\n            });\n        },\n        updateTask: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.map((i) => (i.id === payload.id ? payload : i));\n        },\n        updateTaskContent: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    i.content = payload.updatedTaskContent;\n                }\n            });\n        },\n        updateOrder: (tasks, { payload }) => {\n            tasks.taskArray = payload;\n        },\n\n        focusOnTask: (tasks, { payload }) => {\n            tasks.meta.focussedTaskIndex = payload;\n        },\n        resetFocussedTask: (tasks) => {\n            tasks.meta.focussedTaskIndex = -1;\n        },\n        tick: (tasks, { payload }) => {\n            --tasks.taskArray[payload].remainingTime;\n        },\n        resetTaskTimer: (tasks, { payload }) => {\n            tasks.taskArray[payload].isRunning = false;\n            tasks.taskArray[payload].remainingTime = tasks.taskArray[payload].time;\n        },\n        toggleIsRunning: (tasks, { payload }) => {\n            tasks.taskArray[payload].isRunning = !tasks.taskArray[payload].isRunning;\n        },\n\n        toggleIsCompleted: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    i.isCompleted = !i.isCompleted;\n                }\n            });\n        },\n        incrementGlobalKey: ({ meta }) => {\n            ++meta.globalKey;\n        },\n        rearrange: (tasks, { payload }) => {\n            let id = payload.id;\n\n            if (payload.markedAsComplete) {\n                if (tasks.meta.completedTaskStartIndex === -1) {\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                    let found = false;\n                    for (let i = 0; i < tasks.taskArray.length - 1; i++) {\n                        if (found) {\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        } else if (tasks.taskArray[i].id === id) {\n                            found = true;\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        }\n                    }\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                } else {\n                    let task, idx;\n                    for (let i = 0; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n                    let pos = -1;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].globalKey > task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    if (pos === -1) {\n                        tasks.taskArray.push(task);\n                    } else {\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.meta.completedTaskStartIndex -= 1;\n                }\n            } else {\n                if (tasks.meta.completedTaskStartIndex == 0) {\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.taskArray.unshift(task);\n                    tasks.meta.completedTaskStartIndex = 1;\n                } else {\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    let start = tasks.meta.completedTaskStartIndex - 1;\n                    let pos = -1;\n                    for (let i = start; i >= 0; i--) {\n                        if (tasks.taskArray[i].globalKey < task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    if (pos === -1) {\n                        tasks.taskArray.unshift(task);\n                    } else {\n                        pos++;\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.meta.completedTaskStartIndex += 1;\n                }\n\n                if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length) {\n                    tasks.meta.completedTaskStartIndex = -1;\n                }\n            }\n        },\n    },\n});\n\nexport const {\n    create,\n    remove,\n    updateTask,\n    updateTaskContent,\n    focusOnTask,\n    resetFocussedTask,\n    resetTaskTimer,\n    toggleIsRunning,\n    tick,\n    toggleIsCompleted,\n    updateOrder,\n    incrementGlobalKey,\n    rearrange,\n} = tasksSlice.actions;\n\nexport default tasksSlice.reducer;\n",["72","73"],"/home/pg07codes/Desktop/fokus/src/serviceWorker.js",[],["74","75"],"/home/pg07codes/Desktop/fokus/src/index.js",[],"/home/pg07codes/Desktop/fokus/src/helpers/index.js",["76","77"],"export function formattedTimeString(x) {\n    let secs = x % 60;\n    let mins = Math.floor(x / 60);\n\n    if (secs == 0) {\n        secs = `00`;\n    } else if (secs < 10) {\n        secs = `0${secs}`;\n    }\n    if (mins == 0) {\n        mins = `00`;\n    } else if (mins < 10) {\n        mins = `0${mins}`;\n    }\n\n    return `${mins}:${secs}`;\n}\n\n","/home/pg07codes/Desktop/fokus/src/store/index.js",[],["78","79"],"/home/pg07codes/Desktop/fokus/src/containers/focusBoard/FocusBoard.js",[],"/home/pg07codes/Desktop/fokus/src/containers/taskBoard/TaskBoard.js",["80","81","82"],"/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskInput.js",[],"/home/pg07codes/Desktop/fokus/src/components/TaskBoard/TaskCard.js",["83","84","85"],"import React, { useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { remove, updateTaskContent, toggleIsCompleted, rearrange, updateTask } from \"../../containers/taskBoard/taskBoardSlice\";\nimport { focusOnTask, resetFocussedTask, toggleIsRunning } from \"../../containers/taskBoard/taskBoardSlice\";\nimport styled from \"styled-components\";\nimport { FaRegLightbulb, FaLightbulb, FaCheckCircle } from \"react-icons/fa\";\nimport { BsTrashFill } from \"react-icons/bs\";\nimport { Flipped } from \"react-flip-toolkit\";\nimport { GrDrag } from \"react-icons/gr\";\nimport { formattedTimeString } from \"../../helpers\";\n\nconst TaskCardContainer = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n    width: 476px;\n    height: 120px;\n    margin-top: 25px;\n    /* background-color: #fff4e1; */\n`;\n\nconst TaskCardDragIcon = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n    width: 30px;\n    height: 100%;\n    /* background-color: #ff09ac; */\n    svg {\n        cursor: url(\"https://ssl.gstatic.com/ui/v1/icons/mail/images/2/openhand.cur\"), default !important;\n        font-size: 2em;\n        opacity: 0.6;\n    }\n`;\n\nconst TaskCardDiv = styled.div`\n    display: flex;\n    justify-content: space-around;\n    flex-direction: row;\n    height: 100%;\n    width: 420px;\n    border-radius: 5px;\n    -webkit-box-shadow: ${(props) => (props.isFocussed ? \"0 0 6px rgb(255, 216, 0, 0.6)\" : \"0 0 4px rgb(0, 0, 0, 0.2)\")};\n    box-shadow: ${(props) => (props.isFocussed ? \"0 0 6px rgb(255, 216, 0, 0.6)\" : \"0 0 4px rgb(0, 0, 0, 0.2)\")};\n    border: ${(props) => (props.isFocussed ? \"2px solid #ffd800\" : \"none\")};\n`;\n\nconst TaskDetailsDiv = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: space-around;\n    height: 100%;\n    width: 75%;\n    margin: 0 0 0 10px;\n    /* background-color: #fff1fc; */\n`;\n\nconst TaskContentDiv = styled.div`\n    display: flex;\n    align-items: center;\n    height: 65%;\n    margin: 0 0 0 5px;\n    word-wrap: break-word;\n    /* background-color: #fffcec; */\n    h3:hover {\n        cursor: text;\n    }\n`;\n\nconst TaskEditInput = styled.textarea`\n    resize: none;\n    height: 90%;\n    width: 100%;\n    font-size: 1.17em;\n    font-weight: bold;\n    overflow: hidden;\n    vertical-align: center;\n    &:focus {\n        outline: none;\n        border: 2px #7e8d9f dashed;\n        border-radius: 5px;\n    }\n`;\n\nconst TaskStatusDiv = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    width: 15%;\n    /* background-color: #f8f8ff; */\n    position: relative;\n    p {\n        margin: 5px;\n        font-size: 0.8em;\n    }\n    svg {\n        font-size: 2.5em;\n        color: ${(p) => (p.isCompleted ? \"#00a86b\" : p.isFocussed ? \"#ffd800\" : \"#000\")};\n    }\n`;\n\nconst TaskActionButton = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 80%;\n    border-radius: 5px;\n    margin: 5px;\n    cursor: pointer;\n    &:hover {\n        background-color: #c0c0c0;\n    }\n    p {\n        margin: 5px;\n        font-size: 0.7em;\n    }\n`;\n\nconst TaskDeleteButton = styled.div`\n    height: 80%;\n    cursor: pointer;\n    margin-left: auto;\n    color: #d0d0d0;\n    &:hover {\n        color: #e44d2e;\n    }\n`;\n\nconst TaskControllerDiv = styled.div`\n    display: flex;\n    justify-content: flex-start;\n    align-items: center;\n    height: 25%;\n    /* background-color: #fffa91; */\n    svg {\n        font-size: 20px;\n        margin: 5px;\n    }\n`;\n\nfunction previewTask(str) {\n    if (str.length <= 70) return str;\n    else return str.substring(0, 70) + \"...\";\n}\n\nexport default function TaskCard({ task, taskIndex, forwardRBDProvided, isFocussed }) {\n    const dispatch = useDispatch();\n\n    const [taskUnderEdit, setTaskUnderEdit] = useState(false);\n    const [updatedTaskContent, setUpdatedTaskContent] = useState(task.content);\n    const [showDragIcon, setShowDragIcon] = useState(false);\n\n    function submitUpdatedTaskContent(e) {\n        if (e.key === \"Enter\" && updatedTaskContent.trim().length >= 3) {\n            let temp = updatedTaskContent.trim().split(\" \");\n            let time = 0;\n            if (temp.length !== 1 && !isNaN(parseInt(temp[temp.length - 1]))) {\n                time = parseInt(temp.pop());\n            }\n            temp = temp.join(\" \");\n            // manage to update time also\n            dispatch(updateTaskContent({ id: task.id, updatedTaskContent }));\n            setTaskUnderEdit(false);\n        }\n    }\n\n    return (\n        <Flipped flipId={`${task.id}`}>\n            <TaskCardContainer\n                ref={forwardRBDProvided.innerRef}\n                {...forwardRBDProvided.draggableProps}\n                {...forwardRBDProvided.dragHandleProps}\n                onMouseEnter={() => setShowDragIcon(!task.isCompleted && true)}\n                onMouseLeave={() => setShowDragIcon(!task.isCompleted && false)}\n            >\n                <TaskCardDragIcon>{showDragIcon && <GrDrag />}</TaskCardDragIcon>\n\n                <TaskCardDiv isFocussed={isFocussed}>\n                    <TaskStatusDiv isFocussed={isFocussed} isCompleted={task.isCompleted}>\n                        {task.isCompleted ? <FaCheckCircle /> : isFocussed ? <FaLightbulb /> : <FaRegLightbulb />}\n                        {!task.isCompleted && <p>{formattedTimeString(task.remainingTime)}</p>}\n                    </TaskStatusDiv>\n\n                    <TaskDetailsDiv>\n                        <TaskContentDiv>\n                            {taskUnderEdit ? (\n                                <TaskEditInput\n                                    autoFocus\n                                    value={updatedTaskContent}\n                                    onBlur={() => {\n                                        dispatch(updateTaskContent({ id: task.id, updatedTaskContent }));\n                                        setTaskUnderEdit(false);\n                                    }}\n                                    onKeyDown={submitUpdatedTaskContent}\n                                    onChange={(e) => setUpdatedTaskContent(e.target.value)}\n                                />\n                            ) : (\n                                <h3 style={{ minWidth: 0 }} onDoubleClick={() => setTaskUnderEdit(true)}>\n                                    {previewTask(task.content)}\n                                </h3>\n                            )}\n                        </TaskContentDiv>\n\n                        <TaskControllerDiv>\n                            {!task.isCompleted && (\n                                <TaskActionButton\n                                    onClick={\n                                        isFocussed\n                                            ? () => {\n                                                  if (task.isRunning) dispatch(toggleIsRunning(taskIndex));\n                                                  dispatch(resetFocussedTask());\n                                              }\n                                            : () => {\n                                                  dispatch(focusOnTask(taskIndex));\n                                              }\n                                    }\n                                >\n                                    <p>{isFocussed ? \"Unfocus\" : \"Focus\"}</p>\n                                </TaskActionButton>\n                            )}\n\n                            <TaskActionButton\n                                onClick={\n                                    task.isCompleted\n                                        ? (e) => {\n                                              dispatch(toggleIsCompleted(task.id));\n                                              dispatch(rearrange({ id: task.id, markedAsComplete: false }));\n                                              e.stopPropagation();\n                                          }\n                                        : (e) => {\n                                              if (task.isRunning)dispatch(toggleIsRunning(taskIndex));\n                                              if (isFocussed) dispatch(resetFocussedTask());\n                                              dispatch(toggleIsCompleted(task.id));\n                                              dispatch(rearrange({ id: task.id, markedAsComplete: true }));\n                                              e.stopPropagation();\n                                          }\n                                }\n                            >\n                                <p>{task.isCompleted ? \"Undone\" : \"Done\"}</p>\n                            </TaskActionButton>\n\n                            {!isFocussed && (\n                                <TaskDeleteButton\n                                    onClick={(e) => {\n                                        dispatch(remove(task.id));\n                                        e.stopPropagation();\n                                        if (isFocussed) {\n                                            dispatch(resetFocussedTask());\n                                        }\n                                    }}\n                                >\n                                    <BsTrashFill />\n                                </TaskDeleteButton>\n                            )}\n                        </TaskControllerDiv>\n                    </TaskDetailsDiv>\n                </TaskCardDiv>\n            </TaskCardContainer>\n        </Flipped>\n    );\n}\n","/home/pg07codes/Desktop/fokus/src/components/customIcons/Globe.js",[],"/home/pg07codes/Desktop/fokus/src/components/TaskBoard/Divider.js",[],{"ruleId":"86","replacedBy":"87"},{"ruleId":"88","replacedBy":"89"},{"ruleId":"90","severity":1,"message":"91","line":16,"column":52,"nodeType":"92","messageId":"93","endLine":16,"endColumn":54},{"ruleId":"90","severity":1,"message":"91","line":23,"column":64,"nodeType":"92","messageId":"93","endLine":23,"endColumn":66},{"ruleId":"90","severity":1,"message":"94","line":24,"column":67,"nodeType":"92","messageId":"93","endLine":24,"endColumn":69},{"ruleId":"90","severity":1,"message":"94","line":119,"column":56,"nodeType":"92","messageId":"93","endLine":119,"endColumn":58},{"ruleId":"90","severity":1,"message":"94","line":162,"column":56,"nodeType":"92","messageId":"93","endLine":162,"endColumn":58},{"ruleId":"86","replacedBy":"95"},{"ruleId":"88","replacedBy":"96"},{"ruleId":"86","replacedBy":"97"},{"ruleId":"88","replacedBy":"98"},{"ruleId":"90","severity":1,"message":"94","line":5,"column":14,"nodeType":"92","messageId":"93","endLine":5,"endColumn":16},{"ruleId":"90","severity":1,"message":"94","line":10,"column":14,"nodeType":"92","messageId":"93","endLine":10,"endColumn":16},{"ruleId":"86","replacedBy":"99"},{"ruleId":"88","replacedBy":"100"},{"ruleId":"101","severity":1,"message":"102","line":1,"column":17,"nodeType":"103","messageId":"104","endLine":1,"endColumn":25},{"ruleId":"90","severity":1,"message":"91","line":39,"column":18,"nodeType":"92","messageId":"93","endLine":39,"endColumn":20},{"ruleId":"90","severity":1,"message":"94","line":47,"column":19,"nodeType":"92","messageId":"93","endLine":47,"endColumn":21},{"ruleId":"101","severity":1,"message":"105","line":2,"column":23,"nodeType":"103","messageId":"104","endLine":2,"endColumn":34},{"ruleId":"101","severity":1,"message":"106","line":3,"column":67,"nodeType":"103","messageId":"104","endLine":3,"endColumn":77},{"ruleId":"101","severity":1,"message":"107","line":162,"column":17,"nodeType":"103","messageId":"104","endLine":162,"endColumn":21},"no-native-reassign",["108"],"no-negated-in-lhs",["109"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.",["108"],["109"],["108"],["109"],["108"],["109"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'useSelector' is defined but never used.","'updateTask' is defined but never used.","'time' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]